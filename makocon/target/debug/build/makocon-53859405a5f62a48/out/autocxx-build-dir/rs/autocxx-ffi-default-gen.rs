# [allow (non_snake_case)] # [allow (dead_code)] # [allow (non_upper_case_globals)] # [allow (non_camel_case_types)] # [doc = "Generated using autocxx - do not edit directly"] # [doc = "@generated"] mod ffi { # [doc = r" A trait to be implemented by any type that can be turned"] # [doc = r" into a C++ string."] # [doc = r" This trait is generated once per autocxx FFI mod and each"] # [doc = r" implementation is incompatible and separate, because each"] # [doc = r" will use a function generated independently for each mod"] # [doc = r" in order to do the actual conversion to a C++ string."] pub trait ToCppString { # [doc = r" Convert `self` into a C++ string in a [`cxx::UniquePtr`]."] fn into_cpp (self) -> cxx :: UniquePtr < cxx :: CxxString > ; } impl ToCppString for & str { fn into_cpp (self) -> cxx :: UniquePtr < cxx :: CxxString > { make_string (self) } } impl ToCppString for String { fn into_cpp (self) -> cxx :: UniquePtr < cxx :: CxxString > { make_string (& self) } } impl ToCppString for & String { fn into_cpp (self) -> cxx :: UniquePtr < cxx :: CxxString > { make_string (self) } } impl ToCppString for cxx :: UniquePtr < cxx :: CxxString > { fn into_cpp (self) -> cxx :: UniquePtr < cxx :: CxxString > { self } } # [doc = "A private mod containing the bindings generated by `bindgen`. Do not use the contents directly - the useful parts will be re-exported into the main FFI mod."] mod bindgen { # [repr (transparent)] pub struct __bindgen_marker_Opaque < T : ? Sized > (T) ; # [repr (transparent)] pub struct __bindgen_marker_Reference < T : ? Sized > (T) ; # [repr (transparent)] pub struct __bindgen_marker_RValueReference < T : ? Sized > (T) ; # [allow (non_snake_case , non_camel_case_types , non_upper_case_globals)] pub mod root { # [doc = r" If Bindgen could only determine the size and alignment of a"] # [doc = r" type, it is represented like this."] # [derive (PartialEq , Copy , Clone , Debug , Hash)] # [repr (C)] pub struct __BindgenOpaqueArray < T : Copy , const N : usize > (pub [T ; N]) ; impl < T : Copy + Default , const N : usize > Default for __BindgenOpaqueArray < T , N > { fn default () -> Self { Self ([< T as Default > :: default () ; N]) } } # [repr (C)] pub struct __BindgenUnionField < T > (:: std :: marker :: PhantomData < T >) ; impl < T > __BindgenUnionField < T > { # [inline] pub const fn new () -> Self { __BindgenUnionField (:: std :: marker :: PhantomData) } # [inline] pub unsafe fn as_ref (& self) -> & T { :: std :: mem :: transmute (self) } # [inline] pub unsafe fn as_mut (& mut self) -> & mut T { :: std :: mem :: transmute (self) } } impl < T > :: std :: default :: Default for __BindgenUnionField < T > { # [inline] fn default () -> Self { Self :: new () } } impl < T > :: std :: clone :: Clone for __BindgenUnionField < T > { # [inline] fn clone (& self) -> Self { * self } } impl < T > :: std :: marker :: Copy for __BindgenUnionField < T > { } impl < T > :: std :: fmt :: Debug for __BindgenUnionField < T > { fn fmt (& self , fmt : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { fmt . write_str ("__BindgenUnionField") } } impl < T > :: std :: hash :: Hash for __BindgenUnionField < T > { fn hash < H : :: std :: hash :: Hasher > (& self , _state : & mut H) { } } impl < T > :: std :: cmp :: PartialEq for __BindgenUnionField < T > { fn eq (& self , _other : & __BindgenUnionField < T >) -> bool { true } } impl < T > :: std :: cmp :: Eq for __BindgenUnionField < T > { } # [allow (unused_imports)] use self :: super :: root ; # [allow (unused_imports)] use super :: { __bindgen_marker_Opaque , __bindgen_marker_Reference , __bindgen_marker_RValueReference } ; # [allow (unused_imports)] use autocxx :: c_char16_t as bindgen_cchar16_t ; # [doc = " <div rustbindgen=\"true\" replaces=\"std::unique_ptr\"></div>"] # [repr (C)] pub struct unique_ptr < T , > { pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < T > > , ptr : * mut T , } # [doc = " <div rustbindgen=\"true\" replaces=\"std::vector\"></div>"] # [repr (C)] pub struct vector < T , > { pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < T > > , ptr : * mut T , } # [doc = " <div rustbindgen=\"true\" replaces=\"std::shared_ptr\"></div>"] # [repr (C)] pub struct shared_ptr < T , > { pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < T > > , ptr : * mut T , } # [doc = " <div rustbindgen=\"true\" replaces=\"std::weak_ptr\"></div>"] # [repr (C)] pub struct weak_ptr < T , > { pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < T > > , ptr : * mut T , } # [doc = " <div rustbindgen=\"true\" replaces=\"rust::Str\"></div>"] # [repr (C)] pub struct Str { ptr : * mut :: std :: os :: raw :: c_char , } # [doc = " <div rustbindgen=\"true\" replaces=\"rust::String\"></div>"] # [repr (C)] pub struct String { ptr : * mut :: std :: os :: raw :: c_char , } # [doc = " <div rustbindgen=\"true\" replaces=\"rust::Box\"></div>"] # [repr (C)] pub struct Box < T , > { pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < T > > , ptr : * mut T , } pub mod std { # [allow (unused_imports)] use self :: super :: super :: root ; # [allow (unused_imports)] use super :: { __bindgen_marker_Opaque , __bindgen_marker_Reference , __bindgen_marker_RValueReference } ; # [allow (unused_imports)] use autocxx :: c_char16_t as bindgen_cchar16_t ; # [doc = " <div rustbindgen=\"true\" replaces=\"std::string\"></div>"] # [repr (C)] pub struct string { ptr : * mut :: std :: os :: raw :: c_char , } # [repr (C)] pub struct basic_string < _CharT , > { pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _CharT > > , _M_dataplus : root :: std :: basic_string__Alloc_hider , _M_string_length : root :: std :: basic_string_size_type , __bindgen_anon_1 : root :: std :: basic_string__bindgen_ty_2 < _CharT > , } pub type basic_string__Char_alloc_type = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type basic_string__Alloc_traits = root :: __gnu_cxx :: __alloc_traits ; pub type basic_string_traits_type < _Traits > = _Traits ; pub type basic_string_value_type = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type basic_string_allocator_type = root :: std :: basic_string__Char_alloc_type ; pub type basic_string_size_type = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type basic_string_difference_type = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type basic_string_reference = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type basic_string_const_reference = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type basic_string_pointer = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type basic_string_const_pointer = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type basic_string_iterator = root :: __gnu_cxx :: __normal_iterator < root :: std :: basic_string_pointer > ; pub type basic_string_const_iterator = root :: __gnu_cxx :: __normal_iterator < root :: std :: basic_string_const_pointer > ; pub type basic_string_const_reverse_iterator = root :: std :: reverse_iterator < root :: std :: basic_string_const_iterator > ; pub type basic_string_reverse_iterator = root :: std :: reverse_iterator < root :: std :: basic_string_iterator > ; pub type basic_string___const_iterator = root :: std :: basic_string_const_iterator ; pub type basic_string___sv_type < _CharT > = root :: std :: basic_string_view < _CharT > ; pub type basic_string__If_sv = root :: std :: enable_if_t ; # [repr (C)] pub struct basic_string___sv_wrapper < _CharT , > { pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _CharT > > , pub _M_sv : root :: std :: basic_string___sv_type < _CharT > , } # [repr (C)] pub struct basic_string__Alloc_hider { pub _M_p : root :: std :: basic_string_pointer , } pub const basic_string__S_local_capacity : root :: std :: basic_string__bindgen_ty_1 = basic_string__bindgen_ty_1 :: _S_local_capacity ; # [repr (i32)] # [derive (Clone , Hash , PartialEq , Eq)] pub enum basic_string__bindgen_ty_1 { _S_local_capacity = 0 , } # [repr (C)] pub struct basic_string__bindgen_ty_2 < _CharT , > { pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _CharT > > , pub _M_local_buf : root :: __BindgenUnionField < * mut _CharT > , pub _M_allocated_capacity : root :: __BindgenUnionField < root :: std :: basic_string_size_type > , pub bindgen_union_field : __bindgen_marker_Opaque < u64 > , } pub type streamoff = :: std :: os :: raw :: c_long ; # [repr (C)] pub struct fpos < _StateT , > { pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _StateT > > , _M_off : root :: std :: streamoff , _M_state : _StateT , } pub type streampos = root :: std :: fpos < root :: __mbstate_t > ; pub type integral_constant_value_type < _Tp > = _Tp ; pub type integral_constant_type = __bindgen_marker_Opaque < u8 > ; pub type true_type = __bindgen_marker_Opaque < u8 > ; pub type false_type = __bindgen_marker_Opaque < u8 > ; pub type __enable_if_t = __bindgen_marker_Opaque < u8 > ; # [repr (C)] pub struct __type_identity { pub _address : u8 , } pub type __type_identity_type < _Type > = _Type ; pub mod __detail { # [allow (unused_imports)] use self :: super :: super :: super :: root ; # [allow (unused_imports)] use super :: { __bindgen_marker_Opaque , __bindgen_marker_Reference , __bindgen_marker_RValueReference } ; # [allow (unused_imports)] use autocxx :: c_char16_t as bindgen_cchar16_t ; } # [repr (C)] pub struct __and_ { pub _address : u8 , } # [repr (C)] pub struct is_same { pub _address : u8 , } # [repr (C)] pub struct remove_reference { pub _address : u8 , } pub type remove_reference_type < _Tp > = _Tp ; pub type remove_reference_t = root :: std :: remove_reference ; # [repr (C)] pub struct make_unsigned { pub _address : u8 , } pub type make_unsigned_type = __bindgen_marker_Opaque < u8 > ; pub type enable_if_t = __bindgen_marker_Opaque < u8 > ; # [repr (C)] pub struct __detector { pub _address : u8 , } pub type __detector_type < _Default > = _Default ; pub type __detector___is_detected = root :: std :: false_type ; pub type __detected_or = root :: std :: __detector ; pub type __detected_or_t = root :: std :: __detected_or ; # [repr (C)] pub struct char_traits { pub _address : u8 , } # [repr (C)] pub struct __new_allocator { pub _address : u8 , } pub type __new_allocator_value_type < _Tp > = _Tp ; pub type __new_allocator_size_type = usize ; pub type __new_allocator_difference_type = isize ; pub type __new_allocator_pointer < _Tp > = * mut _Tp ; pub type __new_allocator_const_pointer < _Tp > = * const _Tp ; pub type __new_allocator_reference < _Tp > = __bindgen_marker_Reference < * mut _Tp > ; pub type __new_allocator_const_reference < _Tp > = __bindgen_marker_Reference < * const _Tp > ; # [repr (C)] pub struct __new_allocator_rebind { pub _address : u8 , } pub type __new_allocator_propagate_on_container_move_assignment = root :: std :: true_type ; pub type __allocator_base = root :: std :: __new_allocator ; # [repr (C)] pub struct allocator { pub _address : u8 , } pub type allocator_value_type < _Tp > = _Tp ; pub type allocator_size_type = usize ; pub type allocator_difference_type = isize ; pub type allocator_pointer < _Tp > = * mut _Tp ; pub type allocator_const_pointer < _Tp > = * const _Tp ; pub type allocator_reference < _Tp > = __bindgen_marker_Reference < * mut _Tp > ; pub type allocator_const_reference < _Tp > = __bindgen_marker_Reference < * const _Tp > ; # [repr (C)] pub struct allocator_rebind { pub _address : u8 , } pub type allocator_rebind_other = root :: std :: allocator ; pub type allocator_propagate_on_container_move_assignment = root :: std :: true_type ; pub type allocator_is_always_equal = root :: std :: true_type ; # [repr (C)] pub struct input_iterator_tag { pub _address : u8 , } # [repr (C)] pub struct forward_iterator_tag { pub _address : u8 , } # [repr (C)] pub struct bidirectional_iterator_tag { pub _address : u8 , } # [repr (C)] pub struct iterator { pub _address : u8 , } pub type iterator_iterator_category < _Category > = _Category ; pub type iterator_value_type < _Tp > = _Tp ; pub type iterator_difference_type < _Distance > = _Distance ; pub type iterator_pointer < _Pointer > = _Pointer ; pub type iterator_reference < _Reference > = _Reference ; # [repr (C)] pub struct __iterator_traits { pub _address : u8 , } # [repr (C)] pub struct iterator_traits { pub _address : u8 , } # [repr (C)] pub struct __undefined { _unused : [u8 ; 0] , } # [repr (C)] pub struct __get_first_arg { pub _address : u8 , } pub type __get_first_arg_type = root :: std :: __undefined ; # [repr (C)] pub struct __replace_first_arg { pub _address : u8 , } # [repr (C)] pub struct __ptr_traits_elem { pub _address : u8 , } pub type __ptr_traits_elem_t = root :: std :: __ptr_traits_elem ; pub type __ptr_traits_ptr_to_pointer < _Ptr > = _Ptr ; pub type __ptr_traits_ptr_to_element_type < _Elt > = _Elt ; # [repr (C)] pub struct __ptr_traits_impl { pub _address : u8 , } pub type __ptr_traits_impl___diff_t = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type __ptr_traits_impl___rebind = root :: std :: __type_identity ; pub type __ptr_traits_impl_pointer < _Ptr > = _Ptr ; pub type __ptr_traits_impl_element_type < _Elt > = _Elt ; pub type __ptr_traits_impl_difference_type = root :: std :: __detected_or_t ; pub type __ptr_traits_impl_rebind = root :: std :: __detected_or_t ; # [repr (C)] pub struct pointer_traits { pub _address : u8 , } pub type __ptr_rebind = root :: std :: pointer_traits ; # [repr (C)] pub struct reverse_iterator < _Iterator , > { pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _Iterator > > , current : _Iterator , } pub type reverse_iterator___traits_type = root :: std :: iterator_traits ; pub type reverse_iterator_iterator_type < _Iterator > = _Iterator ; pub type reverse_iterator_pointer = root :: std :: reverse_iterator___traits_type ; pub type reverse_iterator_difference_type = root :: std :: reverse_iterator___traits_type ; pub type reverse_iterator_reference = root :: std :: reverse_iterator___traits_type ; # [repr (C)] pub struct unary_function { pub _address : u8 , } pub type unary_function_argument_type < _Arg > = _Arg ; pub type unary_function_result_type < _Result > = _Result ; # [repr (C)] pub struct binary_function { pub _address : u8 , } pub type binary_function_first_argument_type < _Arg1 > = _Arg1 ; pub type binary_function_second_argument_type < _Arg2 > = _Arg2 ; pub type binary_function_result_type < _Result > = _Result ; # [repr (C)] pub struct less { pub _address : u8 , } # [repr (C)] pub struct _Select1st { pub _address : u8 , } # [repr (C)] pub struct __pair_base { pub _address : u8 , } # [repr (C)] pub struct pair < _T1 , _T2 , > { pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _T1 > > , pub _phantom_1 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _T2 > > , pub first : _T1 , pub second : _T2 , } pub type pair_first_type < _T1 > = _T1 ; pub type pair_second_type < _T2 > = _T2 ; pub type pair__PCCP = __bindgen_marker_Opaque < u8 > ; pub type pair__PCCFP = __bindgen_marker_Opaque < u8 > ; # [repr (C)] pub struct pair___zero_as_null_pointer_constant { pub _address : u8 , } # [repr (C)] pub struct __allocator_traits_base { pub _address : u8 , } # [repr (C)] pub struct __allocator_traits_base___rebind { pub _address : u8 , } pub type __allocator_traits_base___pointer = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type __allocator_traits_base___c_pointer = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type __allocator_traits_base___v_pointer = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type __allocator_traits_base___cv_pointer = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type __allocator_traits_base___pocca = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type __allocator_traits_base___pocma = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type __allocator_traits_base___pocs = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type __allocator_traits_base___equal = root :: std :: __type_identity ; pub type __alloc_rebind = root :: std :: __allocator_traits_base ; # [repr (C)] pub struct allocator_traits { pub _address : u8 , } pub type allocator_traits_allocator_type < _Alloc > = _Alloc ; pub type allocator_traits_value_type = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type allocator_traits_pointer = root :: std :: __detected_or_t ; # [repr (C)] pub struct allocator_traits__Ptr { pub _address : u8 , } pub type allocator_traits__Ptr_type = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; # [repr (C)] pub struct allocator_traits__Diff { pub _address : u8 , } pub type allocator_traits__Diff_type = root :: std :: pointer_traits ; # [repr (C)] pub struct allocator_traits__Size { pub _address : u8 , } pub type allocator_traits_const_pointer = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type allocator_traits_void_pointer = root :: std :: allocator_traits__Ptr ; pub type allocator_traits_const_void_pointer = root :: std :: allocator_traits__Ptr ; pub type allocator_traits_difference_type = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type allocator_traits_size_type = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type allocator_traits_propagate_on_container_copy_assignment = root :: std :: __detected_or_t ; pub type allocator_traits_propagate_on_container_move_assignment = root :: std :: __detected_or_t ; pub type allocator_traits_propagate_on_container_swap = root :: std :: __detected_or_t ; pub type allocator_traits_is_always_equal = root :: std :: __detected_or_t ; pub type allocator_traits_rebind_alloc = root :: std :: __alloc_rebind ; pub type allocator_traits_rebind_traits = root :: std :: allocator_traits ; # [repr (C)] pub struct allocator_traits___construct_helper { pub _address : u8 , } pub type allocator_traits___construct_helper_type < _Alloc > = _Alloc ; pub type allocator_traits___has_construct = root :: std :: allocator_traits___construct_helper ; # [repr (C)] pub struct basic_string_view < _CharT , > { pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _CharT > > , _M_len : usize , _M_str : * const _CharT , } pub type basic_string_view_traits_type < _Traits > = _Traits ; pub type basic_string_view_value_type < _CharT > = _CharT ; pub type basic_string_view_pointer < _CharT > = * mut root :: std :: basic_string_view_value_type < _CharT > ; pub type basic_string_view_const_pointer < _CharT > = * const root :: std :: basic_string_view_value_type < _CharT > ; pub type basic_string_view_reference < _CharT > = __bindgen_marker_Reference < * mut root :: std :: basic_string_view_value_type < _CharT > > ; pub type basic_string_view_const_reference < _CharT > = __bindgen_marker_Reference < * const root :: std :: basic_string_view_value_type < _CharT > > ; pub type basic_string_view_const_iterator < _CharT > = * const root :: std :: basic_string_view_value_type < _CharT > ; pub type basic_string_view_iterator < _CharT > = root :: std :: basic_string_view_const_iterator < _CharT > ; pub type basic_string_view_const_reverse_iterator < _CharT > = root :: std :: reverse_iterator < root :: std :: basic_string_view_const_iterator < _CharT > > ; pub type basic_string_view_reverse_iterator < _CharT > = root :: std :: basic_string_view_const_reverse_iterator < _CharT > ; pub type basic_string_view_size_type = usize ; pub type basic_string_view_difference_type = isize ; pub mod chrono { # [allow (unused_imports)] use self :: super :: super :: super :: root ; # [allow (unused_imports)] use super :: { __bindgen_marker_Opaque , __bindgen_marker_Reference , __bindgen_marker_RValueReference } ; # [allow (unused_imports)] use autocxx :: c_char16_t as bindgen_cchar16_t ; } # [repr (C)] pub struct __shared_mutex_pthread { _M_rwlock : root :: pthread_rwlock_t , } unsafe extern "C" { # [link_name = "\u{1}_ZNSt22__shared_mutex_pthread4lockEv"] pub fn __shared_mutex_pthread_lock_bindgen_original (this : * mut root :: std :: __shared_mutex_pthread) ; } unsafe extern "C" { # [link_name = "\u{1}_ZNSt22__shared_mutex_pthread8try_lockEv"] pub fn __shared_mutex_pthread_try_lock_bindgen_original (this : * mut root :: std :: __shared_mutex_pthread) -> bool ; } unsafe extern "C" { # [link_name = "\u{1}_ZNSt22__shared_mutex_pthread6unlockEv"] pub fn __shared_mutex_pthread_unlock_bindgen_original (this : * mut root :: std :: __shared_mutex_pthread) ; } unsafe extern "C" { # [link_name = "\u{1}_ZNSt22__shared_mutex_pthread11lock_sharedEv"] pub fn __shared_mutex_pthread_lock_shared_bindgen_original (this : * mut root :: std :: __shared_mutex_pthread) ; } unsafe extern "C" { # [link_name = "\u{1}_ZNSt22__shared_mutex_pthread15try_lock_sharedEv"] pub fn __shared_mutex_pthread_try_lock_shared_bindgen_original (this : * mut root :: std :: __shared_mutex_pthread) -> bool ; } unsafe extern "C" { # [link_name = "\u{1}_ZNSt22__shared_mutex_pthread13unlock_sharedEv"] pub fn __shared_mutex_pthread_unlock_shared_bindgen_original (this : * mut root :: std :: __shared_mutex_pthread) ; } unsafe extern "C" { # [link_name = "\u{1}_ZNSt22__shared_mutex_pthread13native_handleEv"] pub fn __shared_mutex_pthread_native_handle_bindgen_original (this : * mut root :: std :: __shared_mutex_pthread) -> * mut :: std :: os :: raw :: c_void ; } unsafe extern "C" { # [link_name = "\u{1}_ZNSt22__shared_mutex_pthreadC1Ev"] pub fn __shared_mutex_pthread___shared_mutex_pthread_bindgen_original (this : * mut root :: std :: __shared_mutex_pthread) ; } unsafe extern "C" { # [link_name = "\u{1}_ZNSt22__shared_mutex_pthreadC1ERKS_"] pub fn __shared_mutex_pthread___shared_mutex_pthread_bindgen_original1 (this : * mut root :: std :: __shared_mutex_pthread , arg1 : __bindgen_marker_Reference < * const root :: std :: __shared_mutex_pthread >) ; } unsafe extern "C" { # [link_name = "\u{1}_ZNSt22__shared_mutex_pthreadD1Ev"] pub fn __shared_mutex_pthread___shared_mutex_pthread_destructor_bindgen_original (this : * mut root :: std :: __shared_mutex_pthread) ; } impl __shared_mutex_pthread { # [inline] pub unsafe fn lock_bindgen_original_bindgen_original (& mut self) { __shared_mutex_pthread_lock_bindgen_original (self) } # [inline] pub unsafe fn try_lock_bindgen_original_bindgen_original (& mut self) -> bool { __shared_mutex_pthread_try_lock_bindgen_original (self) } # [inline] pub unsafe fn unlock_bindgen_original_bindgen_original (& mut self) { __shared_mutex_pthread_unlock_bindgen_original (self) } # [inline] pub unsafe fn lock_shared_bindgen_original_bindgen_original (& mut self) { __shared_mutex_pthread_lock_shared_bindgen_original (self) } # [inline] pub unsafe fn try_lock_shared_bindgen_original_bindgen_original (& mut self) -> bool { __shared_mutex_pthread_try_lock_shared_bindgen_original (self) } # [inline] pub unsafe fn unlock_shared_bindgen_original_bindgen_original (& mut self) { __shared_mutex_pthread_unlock_shared_bindgen_original (self) } # [inline] pub unsafe fn native_handle_bindgen_original_bindgen_original (& mut self) -> * mut :: std :: os :: raw :: c_void { __shared_mutex_pthread_native_handle_bindgen_original (self) } # [inline] pub unsafe fn new_bindgen_original () -> Self { let mut __bindgen_tmp = :: std :: mem :: MaybeUninit :: uninit () ; __shared_mutex_pthread___shared_mutex_pthread_bindgen_original (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new_bindgen_original1 (arg1 : __bindgen_marker_Reference < * const root :: std :: __shared_mutex_pthread >) -> Self { let mut __bindgen_tmp = :: std :: mem :: MaybeUninit :: uninit () ; __shared_mutex_pthread___shared_mutex_pthread_bindgen_original1 (__bindgen_tmp . as_mut_ptr () , arg1) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn destruct_bindgen_original (& mut self) { __shared_mutex_pthread___shared_mutex_pthread_destructor_bindgen_original (self) } } # [repr (C)] pub struct shared_mutex { _M_impl : root :: std :: __shared_mutex_pthread , } pub type shared_mutex_native_handle_type = * mut :: std :: os :: raw :: c_void ; unsafe extern "C" { # [link_name = "\u{1}_ZNSt12shared_mutex4lockEv"] pub fn shared_mutex_lock_bindgen_original (this : * mut root :: std :: shared_mutex) ; } unsafe extern "C" { # [link_name = "\u{1}_ZNSt12shared_mutex8try_lockEv"] pub fn shared_mutex_try_lock_bindgen_original (this : * mut root :: std :: shared_mutex) -> bool ; } unsafe extern "C" { # [link_name = "\u{1}_ZNSt12shared_mutex6unlockEv"] pub fn shared_mutex_unlock_bindgen_original (this : * mut root :: std :: shared_mutex) ; } unsafe extern "C" { # [link_name = "\u{1}_ZNSt12shared_mutex11lock_sharedEv"] pub fn shared_mutex_lock_shared_bindgen_original (this : * mut root :: std :: shared_mutex) ; } unsafe extern "C" { # [link_name = "\u{1}_ZNSt12shared_mutex15try_lock_sharedEv"] pub fn shared_mutex_try_lock_shared_bindgen_original (this : * mut root :: std :: shared_mutex) -> bool ; } unsafe extern "C" { # [link_name = "\u{1}_ZNSt12shared_mutex13unlock_sharedEv"] pub fn shared_mutex_unlock_shared_bindgen_original (this : * mut root :: std :: shared_mutex) ; } unsafe extern "C" { # [link_name = "\u{1}_ZNSt12shared_mutex13native_handleEv"] pub fn shared_mutex_native_handle_bindgen_original (this : * mut root :: std :: shared_mutex) -> root :: std :: shared_mutex_native_handle_type ; } unsafe extern "C" { # [link_name = "\u{1}_ZNSt12shared_mutexC1Ev"] pub fn shared_mutex_shared_mutex_bindgen_original (this : * mut root :: std :: shared_mutex) ; } unsafe extern "C" { # [link_name = "\u{1}_ZNSt12shared_mutexC1ERKS_"] pub fn shared_mutex_shared_mutex_bindgen_original1 (this : * mut root :: std :: shared_mutex , arg1 : __bindgen_marker_Reference < * const root :: std :: shared_mutex >) ; } unsafe extern "C" { # [link_name = "\u{1}_ZNSt12shared_mutexD1Ev"] pub fn shared_mutex_shared_mutex_destructor_bindgen_original (this : * mut root :: std :: shared_mutex) ; } impl shared_mutex { # [inline] pub unsafe fn lock_bindgen_original_bindgen_original (& mut self) { shared_mutex_lock_bindgen_original (self) } # [inline] pub unsafe fn try_lock_bindgen_original_bindgen_original (& mut self) -> bool { shared_mutex_try_lock_bindgen_original (self) } # [inline] pub unsafe fn unlock_bindgen_original_bindgen_original (& mut self) { shared_mutex_unlock_bindgen_original (self) } # [inline] pub unsafe fn lock_shared_bindgen_original_bindgen_original (& mut self) { shared_mutex_lock_shared_bindgen_original (self) } # [inline] pub unsafe fn try_lock_shared_bindgen_original_bindgen_original (& mut self) -> bool { shared_mutex_try_lock_shared_bindgen_original (self) } # [inline] pub unsafe fn unlock_shared_bindgen_original_bindgen_original (& mut self) { shared_mutex_unlock_shared_bindgen_original (self) } # [inline] pub unsafe fn native_handle_bindgen_original_bindgen_original (& mut self) -> root :: std :: shared_mutex_native_handle_type { shared_mutex_native_handle_bindgen_original (self) } # [inline] pub unsafe fn new_bindgen_original () -> Self { let mut __bindgen_tmp = :: std :: mem :: MaybeUninit :: uninit () ; shared_mutex_shared_mutex_bindgen_original (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn new_bindgen_original1 (arg1 : __bindgen_marker_Reference < * const root :: std :: shared_mutex >) -> Self { let mut __bindgen_tmp = :: std :: mem :: MaybeUninit :: uninit () ; shared_mutex_shared_mutex_bindgen_original1 (__bindgen_tmp . as_mut_ptr () , arg1) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn destruct_bindgen_original (& mut self) { shared_mutex_shared_mutex_destructor_bindgen_original (self) } } # [repr (C)] pub struct _Node_handle_common < _NodeAlloc , > { pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _NodeAlloc > > , _M_ptr : root :: std :: _Node_handle_common__AllocTraits , _M_alloc : root :: std :: _Node_handle_common__Optional_alloc < _NodeAlloc > , } pub type _Node_handle_common__AllocTraits = root :: std :: allocator_traits ; pub type _Node_handle_common_allocator_type = root :: std :: __alloc_rebind ; # [repr (C)] # [repr (align (1))] pub struct _Node_handle_common__Optional_alloc < _NodeAlloc , > { pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _NodeAlloc > > , pub _M_alloc : root :: __BindgenUnionField < _NodeAlloc > , pub bindgen_union_field : __bindgen_marker_Opaque < [u8 ; 0usize] > , } # [repr (C)] pub struct _Node_handle < _NodeAlloc , > { pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _NodeAlloc > > , pub _base : root :: std :: _Node_handle_common < _NodeAlloc > , _M_pkey : root :: std :: _Node_handle___pointer , _M_pmapped : root :: std :: _Node_handle___pointer , } pub type _Node_handle_key_type < _Key > = _Key ; pub type _Node_handle_mapped_type = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type _Node_handle__AllocTraits = root :: std :: allocator_traits ; pub type _Node_handle___pointer = root :: std :: __ptr_rebind ; # [repr (C)] pub struct _Node_insert_return < _Iterator , _NodeHandle , > { pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _Iterator > > , pub _phantom_1 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _NodeHandle > > , pub position : _Iterator , pub inserted : bool , pub node : _NodeHandle , } # [repr (u32)] # [derive (Clone , Hash , PartialEq , Eq)] pub enum _Rb_tree_color { _S_red = 0 , _S_black = 1 , } # [repr (C)] pub struct _Rb_tree_node_base { pub _M_color : root :: std :: _Rb_tree_color , pub _M_parent : root :: std :: _Rb_tree_node_base__Base_ptr , pub _M_left : root :: std :: _Rb_tree_node_base__Base_ptr , pub _M_right : root :: std :: _Rb_tree_node_base__Base_ptr , } pub type _Rb_tree_node_base__Base_ptr = * mut root :: std :: _Rb_tree_node_base ; pub type _Rb_tree_node_base__Const_Base_ptr = * const root :: std :: _Rb_tree_node_base ; unsafe extern "C" { # [link_name = "\u{1}_ZNSt18_Rb_tree_node_base10_S_minimumEPS_"] pub fn _Rb_tree_node_base__S_minimum_bindgen_original (__x : root :: std :: _Rb_tree_node_base__Base_ptr) -> root :: std :: _Rb_tree_node_base__Base_ptr ; } unsafe extern "C" { # [link_name = "\u{1}_ZNSt18_Rb_tree_node_base10_S_minimumEPKS_"] pub fn _Rb_tree_node_base__S_minimum_bindgen_original1 (__x : root :: std :: _Rb_tree_node_base__Const_Base_ptr) -> root :: std :: _Rb_tree_node_base__Const_Base_ptr ; } unsafe extern "C" { # [link_name = "\u{1}_ZNSt18_Rb_tree_node_base10_S_maximumEPS_"] pub fn _Rb_tree_node_base__S_maximum_bindgen_original (__x : root :: std :: _Rb_tree_node_base__Base_ptr) -> root :: std :: _Rb_tree_node_base__Base_ptr ; } unsafe extern "C" { # [link_name = "\u{1}_ZNSt18_Rb_tree_node_base10_S_maximumEPKS_"] pub fn _Rb_tree_node_base__S_maximum_bindgen_original1 (__x : root :: std :: _Rb_tree_node_base__Const_Base_ptr) -> root :: std :: _Rb_tree_node_base__Const_Base_ptr ; } impl _Rb_tree_node_base { # [inline] pub unsafe fn _S_minimum_bindgen_original_bindgen_original (__x : root :: std :: _Rb_tree_node_base__Base_ptr) -> root :: std :: _Rb_tree_node_base__Base_ptr { _Rb_tree_node_base__S_minimum_bindgen_original (__x) } # [inline] pub unsafe fn _S_minimum_bindgen_original_bindgen_original1 (__x : root :: std :: _Rb_tree_node_base__Const_Base_ptr) -> root :: std :: _Rb_tree_node_base__Const_Base_ptr { _Rb_tree_node_base__S_minimum_bindgen_original1 (__x) } # [inline] pub unsafe fn _S_maximum_bindgen_original_bindgen_original (__x : root :: std :: _Rb_tree_node_base__Base_ptr) -> root :: std :: _Rb_tree_node_base__Base_ptr { _Rb_tree_node_base__S_maximum_bindgen_original (__x) } # [inline] pub unsafe fn _S_maximum_bindgen_original_bindgen_original1 (__x : root :: std :: _Rb_tree_node_base__Const_Base_ptr) -> root :: std :: _Rb_tree_node_base__Const_Base_ptr { _Rb_tree_node_base__S_maximum_bindgen_original1 (__x) } } # [repr (C)] pub struct _Rb_tree_key_compare < _Key_compare , > { pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _Key_compare > > , pub _M_key_compare : _Key_compare , } # [repr (C)] pub struct _Rb_tree_node { pub _base : root :: std :: _Rb_tree_node_base , pub _M_storage : root :: __gnu_cxx :: __aligned_membuf , } pub type _Rb_tree_node__Link_type = * mut root :: std :: _Rb_tree_node ; # [repr (C)] pub struct _Rb_tree_iterator { pub _M_node : root :: std :: _Rb_tree_iterator__Base_ptr , } pub type _Rb_tree_iterator_value_type < _Tp > = _Tp ; pub type _Rb_tree_iterator_reference < _Tp > = __bindgen_marker_Reference < * mut _Tp > ; pub type _Rb_tree_iterator_pointer < _Tp > = * mut _Tp ; pub type _Rb_tree_iterator_iterator_category = root :: std :: bidirectional_iterator_tag ; pub type _Rb_tree_iterator_difference_type = isize ; pub type _Rb_tree_iterator__Self = root :: std :: _Rb_tree_iterator ; pub type _Rb_tree_iterator__Base_ptr = root :: std :: _Rb_tree_node_base__Base_ptr ; pub type _Rb_tree_iterator__Link_type = * mut root :: std :: _Rb_tree_node ; # [repr (C)] pub struct _Rb_tree_const_iterator { pub _M_node : root :: std :: _Rb_tree_const_iterator__Base_ptr , } pub type _Rb_tree_const_iterator_value_type < _Tp > = _Tp ; pub type _Rb_tree_const_iterator_reference < _Tp > = __bindgen_marker_Reference < * const _Tp > ; pub type _Rb_tree_const_iterator_pointer < _Tp > = * const _Tp ; pub type _Rb_tree_const_iterator_iterator = root :: std :: _Rb_tree_iterator ; pub type _Rb_tree_const_iterator_iterator_category = root :: std :: bidirectional_iterator_tag ; pub type _Rb_tree_const_iterator_difference_type = isize ; pub type _Rb_tree_const_iterator__Self = root :: std :: _Rb_tree_const_iterator ; pub type _Rb_tree_const_iterator__Base_ptr = root :: std :: _Rb_tree_node_base__Const_Base_ptr ; pub type _Rb_tree_const_iterator__Link_type = * const root :: std :: _Rb_tree_node ; # [repr (C)] pub struct _Rb_tree { _M_impl : __bindgen_marker_Opaque < u8 > , } pub type _Rb_tree__Node_allocator = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type _Rb_tree__Alloc_traits = root :: __gnu_cxx :: __alloc_traits ; pub type _Rb_tree__Base_ptr = * mut root :: std :: _Rb_tree_node_base ; pub type _Rb_tree__Const_Base_ptr = * const root :: std :: _Rb_tree_node_base ; pub type _Rb_tree__Link_type = * mut root :: std :: _Rb_tree_node ; pub type _Rb_tree__Const_Link_type = * const root :: std :: _Rb_tree_node ; # [repr (C)] pub struct _Rb_tree__Reuse_or_alloc_node { _M_root : root :: std :: _Rb_tree__Base_ptr , _M_nodes : root :: std :: _Rb_tree__Base_ptr , _M_t : __bindgen_marker_Reference < * mut root :: std :: _Rb_tree > , } # [repr (C)] pub struct _Rb_tree__Alloc_node { _M_t : __bindgen_marker_Reference < * mut root :: std :: _Rb_tree > , } pub type _Rb_tree_key_type < _Key > = _Key ; pub type _Rb_tree_value_type < _Val > = _Val ; pub type _Rb_tree_pointer < _Val > = * mut root :: std :: _Rb_tree_value_type < _Val > ; pub type _Rb_tree_const_pointer < _Val > = * const root :: std :: _Rb_tree_value_type < _Val > ; pub type _Rb_tree_reference < _Val > = __bindgen_marker_Reference < * mut root :: std :: _Rb_tree_value_type < _Val > > ; pub type _Rb_tree_const_reference < _Val > = __bindgen_marker_Reference < * const root :: std :: _Rb_tree_value_type < _Val > > ; pub type _Rb_tree_size_type = usize ; pub type _Rb_tree_difference_type = isize ; pub type _Rb_tree_allocator_type < _Alloc > = _Alloc ; pub type _Rb_tree_reverse_iterator = root :: std :: reverse_iterator < root :: std :: _Rb_tree_iterator > ; pub type _Rb_tree_const_reverse_iterator = root :: std :: reverse_iterator < root :: std :: _Rb_tree_const_iterator > ; pub type _Rb_tree_node_type = root :: std :: _Node_handle < root :: std :: _Rb_tree__Node_allocator > ; pub type _Rb_tree_insert_return_type = root :: std :: _Node_insert_return < _Iterator , _NodeHandle > ; pub const _Rb_tree___as_lvalue : root :: std :: _Rb_tree__bindgen_ty_1 = _Rb_tree__bindgen_ty_1 :: __as_lvalue ; pub const _Rb_tree___as_rvalue : root :: std :: _Rb_tree__bindgen_ty_1 = _Rb_tree__bindgen_ty_1 :: __as_lvalue ; # [repr (i32)] # [derive (Clone , Hash , PartialEq , Eq)] pub enum _Rb_tree__bindgen_ty_1 { __as_lvalue = 0 , } pub type _Rb_tree___same_value_type = root :: std :: is_same ; pub type _Rb_tree__Compatible_tree = root :: std :: _Rb_tree ; # [repr (C)] pub struct _Rb_tree__Auto_node { pub _M_t : __bindgen_marker_Reference < * mut root :: std :: _Rb_tree > , pub _M_node : root :: std :: _Rb_tree__Link_type , } pub type _Rb_tree__Rb_tree_impl__Base_key_compare < _Key_compare > = root :: std :: _Rb_tree_key_compare < _Key_compare > ; # [repr (C)] pub struct map { _M_t : root :: std :: map__Rep_type , } pub type map_key_type < _Key > = _Key ; pub type map_mapped_type < _Tp > = _Tp ; pub type map_value_type < _Key , _Tp > = root :: std :: pair < _Key , _Tp > ; pub type map_key_compare < _Compare > = _Compare ; pub type map_allocator_type < _Alloc > = _Alloc ; # [repr (C)] pub struct map_value_compare < _Compare , > { pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _Compare > > , comp : _Compare , } pub type map__Pair_alloc_type = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type map__Rep_type = root :: std :: _Rb_tree ; pub type map__Alloc_traits = root :: __gnu_cxx :: __alloc_traits ; pub type map_pointer = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type map_const_pointer = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type map_reference = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type map_const_reference = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type map_iterator = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type map_const_iterator = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type map_size_type = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type map_difference_type = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type map_reverse_iterator = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type map_const_reverse_iterator = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type map_node_type = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; pub type map_insert_return_type = __bindgen_marker_Opaque < root :: __BindgenOpaqueArray < u8 , 0usize > > ; } pub mod __gnu_cxx { # [allow (unused_imports)] use self :: super :: super :: root ; # [allow (unused_imports)] use super :: { __bindgen_marker_Opaque , __bindgen_marker_Reference , __bindgen_marker_RValueReference } ; # [allow (unused_imports)] use autocxx :: c_char16_t as bindgen_cchar16_t ; # [repr (C)] pub struct _Char_types { pub _address : u8 , } pub type _Char_types_int_type = :: std :: os :: raw :: c_ulong ; pub type _Char_types_pos_type = root :: std :: streampos ; pub type _Char_types_off_type = root :: std :: streamoff ; pub type _Char_types_state_type = root :: __mbstate_t ; # [repr (C)] pub struct char_traits { pub _address : u8 , } pub type char_traits_char_type < _CharT > = _CharT ; pub type char_traits_int_type = root :: __gnu_cxx :: _Char_types ; pub type char_traits_pos_type = root :: __gnu_cxx :: _Char_types ; pub type char_traits_off_type = root :: __gnu_cxx :: _Char_types ; pub type char_traits_state_type = root :: __gnu_cxx :: _Char_types ; # [repr (C)] pub struct __normal_iterator < _Iterator , > { pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _Iterator > > , _M_current : _Iterator , } pub type __normal_iterator___traits_type = root :: std :: iterator_traits ; pub type __normal_iterator___convertible_from = root :: std :: __enable_if_t ; pub type __normal_iterator_iterator_type < _Iterator > = _Iterator ; pub type __normal_iterator_iterator_category = root :: __gnu_cxx :: __normal_iterator___traits_type ; pub type __normal_iterator_value_type = root :: __gnu_cxx :: __normal_iterator___traits_type ; pub type __normal_iterator_difference_type = root :: __gnu_cxx :: __normal_iterator___traits_type ; pub type __normal_iterator_reference = root :: __gnu_cxx :: __normal_iterator___traits_type ; pub type __normal_iterator_pointer = root :: __gnu_cxx :: __normal_iterator___traits_type ; # [repr (C)] pub struct __alloc_traits { pub _address : u8 , } pub type __alloc_traits_allocator_type < _Alloc > = _Alloc ; pub type __alloc_traits__Base_type = root :: std :: allocator_traits ; pub type __alloc_traits_value_type = root :: __gnu_cxx :: __alloc_traits__Base_type ; pub type __alloc_traits_pointer = root :: __gnu_cxx :: __alloc_traits__Base_type ; pub type __alloc_traits_const_pointer = root :: __gnu_cxx :: __alloc_traits__Base_type ; pub type __alloc_traits_size_type = root :: __gnu_cxx :: __alloc_traits__Base_type ; pub type __alloc_traits_difference_type = root :: __gnu_cxx :: __alloc_traits__Base_type ; pub type __alloc_traits_reference = __bindgen_marker_Reference < * mut root :: __gnu_cxx :: __alloc_traits_value_type > ; pub type __alloc_traits_const_reference = __bindgen_marker_Reference < * const root :: __gnu_cxx :: __alloc_traits_value_type > ; pub type __alloc_traits___is_custom_pointer = root :: std :: __and_ ; # [repr (C)] pub struct __alloc_traits_rebind { pub _address : u8 , } pub type __alloc_traits_rebind_other = root :: __gnu_cxx :: __alloc_traits__Base_type ; # [repr (C)] pub struct __aligned_membuf { pub _M_storage : * mut :: std :: os :: raw :: c_uchar , } # [repr (C)] pub struct __aligned_membuf__Tp2 < _Tp , > { pub _phantom_0 : :: std :: marker :: PhantomData < :: std :: cell :: UnsafeCell < _Tp > > , pub _M_t : _Tp , } } # [repr (C)] pub struct __mbstate_t { pub __count : :: std :: os :: raw :: c_int , pub __value : root :: __mbstate_t__bindgen_ty_1 , } # [repr (C)] pub struct __mbstate_t__bindgen_ty_1 { pub __wch : root :: __BindgenUnionField < :: std :: os :: raw :: c_uint > , pub __wchb : root :: __BindgenUnionField < [:: std :: os :: raw :: c_char ; 4usize] > , pub bindgen_union_field : __bindgen_marker_Opaque < u32 > , } # [repr (C)] pub struct __pthread_rwlock_arch_t { pub __readers : :: std :: os :: raw :: c_uint , pub __writers : :: std :: os :: raw :: c_uint , pub __wrphase_futex : :: std :: os :: raw :: c_uint , pub __writers_futex : :: std :: os :: raw :: c_uint , pub __pad3 : :: std :: os :: raw :: c_uint , pub __pad4 : :: std :: os :: raw :: c_uint , pub __cur_writer : :: std :: os :: raw :: c_int , pub __shared : :: std :: os :: raw :: c_int , pub __rwelision : :: std :: os :: raw :: c_schar , pub __pad1 : [:: std :: os :: raw :: c_uchar ; 7usize] , pub __pad2 : :: std :: os :: raw :: c_ulong , pub __flags : :: std :: os :: raw :: c_uint , } # [repr (C)] pub struct pthread_rwlock_t { pub __data : root :: __BindgenUnionField < root :: __pthread_rwlock_arch_t > , pub __size : root :: __BindgenUnionField < [:: std :: os :: raw :: c_char ; 56usize] > , pub __align : root :: __BindgenUnionField < :: std :: os :: raw :: c_long > , pub bindgen_union_field : __bindgen_marker_Opaque < [u64 ; 7usize] > , } # [repr (C)] pub struct KVStore { mutex_ : root :: std :: shared_mutex , store_ : root :: std :: map , } unsafe extern "C" { # [link_name = "\u{1}_ZN7KVStore3setERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEES7_"] pub fn KVStore_set_bindgen_original (this : * mut root :: KVStore , key : __bindgen_marker_Reference < * const root :: std :: string > , value : __bindgen_marker_Reference < * const root :: std :: string >) ; } unsafe extern "C" { # [link_name = "\u{1}_ZNK7KVStore3getERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEERS5_"] pub fn KVStore_get_bindgen_original (this : * const root :: KVStore , key : __bindgen_marker_Reference < * const root :: std :: string > , value : __bindgen_marker_Reference < * mut root :: std :: string >) -> bool ; } unsafe extern "C" { # [link_name = "\u{1}_ZN7KVStore3delERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEE"] pub fn KVStore_del_bindgen_original (this : * mut root :: KVStore , key : __bindgen_marker_Reference < * const root :: std :: string >) -> bool ; } unsafe extern "C" { # [link_name = "\u{1}_ZN7KVStoreC1Ev"] pub fn KVStore_KVStore_bindgen_original (this : * mut root :: KVStore) ; } unsafe extern "C" { # [link_name = "\u{1}_ZN7KVStoreD1Ev"] pub fn KVStore_KVStore_destructor_bindgen_original (this : * mut root :: KVStore) ; } impl KVStore { # [inline] pub unsafe fn set_bindgen_original_bindgen_original (& mut self , key : __bindgen_marker_Reference < * const root :: std :: string > , value : __bindgen_marker_Reference < * const root :: std :: string >) { KVStore_set_bindgen_original (self , key , value) } # [inline] pub unsafe fn get_bindgen_original_bindgen_original (& self , key : __bindgen_marker_Reference < * const root :: std :: string > , value : __bindgen_marker_Reference < * mut root :: std :: string >) -> bool { KVStore_get_bindgen_original (self , key , value) } # [inline] pub unsafe fn del_bindgen_original_bindgen_original (& mut self , key : __bindgen_marker_Reference < * const root :: std :: string >) -> bool { KVStore_del_bindgen_original (self , key) } # [inline] pub unsafe fn new_bindgen_original () -> Self { let mut __bindgen_tmp = :: std :: mem :: MaybeUninit :: uninit () ; KVStore_KVStore_bindgen_original (__bindgen_tmp . as_mut_ptr ()) ; __bindgen_tmp . assume_init () } # [inline] pub unsafe fn destruct_bindgen_original (& mut self) { KVStore_KVStore_destructor_bindgen_original (self) } } # [repr (C)] pub struct _bindgen_ty_13 { pub _address : u8 , } } } # [doc = r" A private mod containing the bindings generated by [`cxx`]. Do not use the contents directly - the useful parts will be re-exported into the main FFI mod."] # [cxx :: bridge] mod cxxbridge { impl UniquePtr < KVStore > { } impl SharedPtr < KVStore > { } impl WeakPtr < KVStore > { } unsafe extern "C++" { # [doc = r" Make a C++ [`cxx::UniquePtr`] to a [`cxx::CxxString`]"] # [doc = r" from a Rust `&str`."] fn autocxx_make_string_0x995a20c818150c48 (str_ : & str) -> UniquePtr < CxxString > ; pub unsafe fn KVStore_autocxx_alloc_autocxx_wrapper_0x995a20c818150c48 () -> * mut KVStore ; pub unsafe fn KVStore_autocxx_free_autocxx_wrapper_0x995a20c818150c48 (arg0 : * mut KVStore) ; # [cxx_name = "KVStore"] type KVStore = super :: KVStore ; pub fn set (self : Pin < & mut KVStore > , key : & CxxString , value : & CxxString) ; pub fn get (self : & KVStore , key : & CxxString , value : Pin < & mut CxxString >) -> bool ; pub fn del (self : Pin < & mut KVStore > , key : & CxxString) -> bool ; pub unsafe fn KVStore_new_autocxx_autocxx_wrapper_0x995a20c818150c48 (autocxx_gen_this : * mut KVStore) ; pub unsafe fn KVStore_destructor_autocxx_wrapper_0x995a20c818150c48 (autocxx_gen_this : * mut KVStore) ; include ! ("kv_store.h") ; include ! ("autocxxgen_ffi.h") ; } extern "Rust" { } } # [allow (unused_imports)] use bindgen :: root ; # [allow (unused_imports)] use super :: ffi as output ; pub use cxxbridge :: autocxx_make_string_0x995a20c818150c48 as make_string ; # [repr (transparent)] pub struct KVStore { _hidden_contents : :: core :: cell :: UnsafeCell < :: core :: mem :: MaybeUninit < bindgen :: root :: KVStore > > , } unsafe impl cxx :: ExternType for KVStore { type Id = cxx :: type_id ! ("KVStore") ; type Kind = cxx :: kind :: Opaque ; } impl KVStore { pub fn new () -> impl autocxx :: moveit :: new :: New < Output = Self > { unsafe { autocxx :: moveit :: new :: by_raw (move | this | { let this = this . get_unchecked_mut () . as_mut_ptr () ; cxxbridge :: KVStore_new_autocxx_autocxx_wrapper_0x995a20c818150c48 (this) }) } } } unsafe impl autocxx :: moveit :: MakeCppStorage for output :: KVStore { unsafe fn allocate_uninitialized_cpp_storage () -> * mut output :: KVStore { cxxbridge :: KVStore_autocxx_alloc_autocxx_wrapper_0x995a20c818150c48 () } unsafe fn free_uninitialized_cpp_storage (arg0 : * mut output :: KVStore) { cxxbridge :: KVStore_autocxx_free_autocxx_wrapper_0x995a20c818150c48 (arg0) } } impl Drop for output :: KVStore { fn drop (self : & mut output :: KVStore) { unsafe { cxxbridge :: KVStore_destructor_autocxx_wrapper_0x995a20c818150c48 (self) } } } }